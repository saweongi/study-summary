### Java 언어의 특징

1. **플랫폼 독립성:** Java는 "한 번 작성하면 어디에서나 실행할 수 있다(Write Once, Run Anywhere)"는 특징을 가지고 있습니다. Java로 작성된 프로그램은 Java Virtual Machine(JVM)에서 실행되므로, JVM이 설치된 모든 플랫폼에서 동일하게 실행될 수 있습니다.

2. **객체 지향 언어:** Java는 완전한 객체 지향 언어입니다. Java에서는 클래스와 객체를 이용하여 코드를 구조화하고, 상속, 캡슐화, 다형성 등의 객체 지향 개념을 지원합니다.

3. **안전성:** Java는 안전성을 위한 여러 가지 체크 메커니즘을 제공합니다. 예를 들어, 포인터를 직접 조작할 수 없으며, 메모리 관리는 가비지 컬렉터에 의해 자동으로 처리됩니다.

4. **다양한 API:** Java는 다양한 용도의 프로그래밍을 지원하는 풍부한 API를 제공합니다. GUI 프로그래밍, 데이터베이스 연동, 네트워킹 등에 필요한 클래스와 인터페이스가 제공됩니다.

5. **다중 스레드 지원:** Java는 다중 스레드를 쉽게 구현할 수 있는 방법을 제공합니다. 이를 통해 복잡한 동시성 작업을 쉽게 처리할 수 있습니다.


### Java의 기본 타입과 참조 타입

Java는 두 가지 주요 데이터 타입을 가지고 있습니다: 기본 타입(primitive types)과 참조 타입(reference types).

**기본 타입**은 자바가 미리 정의하고 제공하는 타입으로, 실제 값을 저장합니다. Java에는 8개의 기본 타입이 있습니다:

1. 정수 타입: `byte`, `short`, `int`, `long`
2. 부동소수점 타입: `float`, `double`
3. 문자 타입: `char`
4. 논리 타입: `boolean`

**참조 타입**은 객체의 주소를 참조하는 타입으로, 클래스, 인터페이스, 배열 등이 있습니다. 참조 타입의 변수는 실제 데이터 대신 데이터의 주소를 저장합니다. 객체는 힙 메모리 영역에 생성되며, 변수는 이 객체의 메모리 주소를 저장합니다.

### Java의 Casting

Casting은 한 타입의 값을 다른 타입으로 변환하는 과정을 말합니다. Java에서는 두 가지 타입의 캐스팅, 즉 "업 캐스팅(Upcasting)"과 "다운 캐스팅(Downcasting)"이 있습니다.

1. **업 캐스팅:** 서브 클래스의 인스턴스를 슈퍼 클래스 타입으로 변환하는 것입니다. 업 캐스팅은 항상 안전하며, 자동으로 수행됩니다.

2. **다운 캐스팅:** 슈퍼 클래스의 인스턴스를 서브 클래스 타입으로 변환하는 것입니다. 다운 캐스팅은 명시적으로 수행해야 하며, 런타임에서 타입 체크가 이루어집니다.

### Java의 변수 사용 범위 (Scope)

변수의 사용 범위는 해당 변수가 접근 가능한 영역을 의미합니다. Java에서는 변수의 선언 위치에 따라 사용 범위가 결정됩니다.

1. **지역 변수 (Local Variables):** 메소드 또는 생성자 내부에서 선언된 변수입니다. 지역 변수는 해당 메소드 또는 생성자가 실행되는 동안에만 접근 가능하며, 이외의 영역에서는 접근할 수 없습니다.

2. **멤버 변수 (Member Variables):** 클래스의 내부, 메소드 및 생성자 외부에서 선언된 변수입니다. 멤버 변수는 해당 클래스의 모든 메소드에서 접근할 수 있습니다.

3. **클래스 변수 (Class Variables):** `static` 키워드를 사용하여 선언된 멤버 변수를 말합니다. 클래스 변수는 클래스 레벨에서 접근 가능하며, 클래스의 모든 인스턴스가 공유합니다.

### Java의 증감 연산자와 대입 연산자

**증감 연산자**

Java에서는 변수의 값을 1 증가시키거나 감소시키는데 사용하는 `++`와 `--` 연산자를 제공합니다. 이들 연산자는 변수 앞(prefix)또는 뒤(suffix)에 위치할 수 있으며, 위치에 따라 동작이 약간 다릅니다.

1. **프리픽스 (Prefix) 증감 연산자:** 연산자가 변수 앞에 오는 경우, 먼저 증가시키거나 감소시킨 후 해당 값을 평가합니다.

2. **포스트픽스 (Postfix) 증감 연산자:** 연산자가 변수 뒤에 오는 경우, 먼저 변수를 평가하고 그 다음에 값을 증가시키거나 감소시킵니다.

**대입 연산자**

`=` 연산자는 값을 저장하는 데 사용되며, 오른쪽 피연산자의 값을 왼쪽 피연산자에 대입합니다. 또한, 산술 연산자와 함께 사용되어 복합 대입 연

산자를 형성할 수 있습니다. (`+=`, `-=`, `*=`, `/=`, `%=` 등)

### Java의 for문 실행 순서

Java의 `for` 반복문은 초기화, 조건 검사, 명령문 실행, 업데이트 순으로 실행됩니다.

1. **초기화:** 반복문의 시작에 한 번만 수행됩니다. 보통 카운터 변수를 초기화하는 데 사용됩니다.

2. **조건 검사:** 반복문의 실행을 계속할지 결정하는 조건을 평가합니다. 조건이 `true`이면 반복문의 본문이 실행되고, `false`이면 반복문이 종료됩니다.

3. **명령문 실행:** 반복문의 본문(중괄호 `{}` 안의 코드)이 실행됩니다.

4. **업데이트:** 각 반복의 마지막에서 실행됩니다. 보통 카운터 변수를 증가 또는 감소시키는 데 사용됩니다.

위 단계가 완료되면 다시 조건 검사 단계로 이동하여, 조건이 `true`일 동안 명령문 실행과 업데이트를 반복적으로 수행합니다.

### Java 메소드의 특징

메소드는 특정 작업을 수행하는 코드의 집합입니다. Java의 메소드는 다음과 같은 특징을 가집니다.

1. **코드 재사용:** 메소드는 한 번 정의하고 여러 번 호출할 수 있어 코드의 재사용성을 증가시킵니다.

2. **모듈화:** 메소드를 사용하면 프로그램을 작은 단위로 나눌 수 있습니다. 이는 코드의 가독성과 유지 관리를 용이하게 합니다.

3. **명확한 결과:** 메소드는 특정 작업을 수행하고 그 결과를 반환합니다.

4. **매개변수:** 메소드는 매개변수를 통해 값을 전달받을 수 있습니다. 이를 통해 동적으로 데이터를 처리할 수 있습니다.

### Java 배열의 특징과 사용법

배열은 같은 타입의 여러 변수를 하나의 이름으로 그룹화하여 관리하는 데이터 구조입니다.

1. **고정된 크기:** 배열의 크기는 선언 시에 결정되며, 이후로 변경할 수 없습니다.

2. **동일한 데이터 타입:** 배열의 모든 요소는 동일한 데이터 타입이어야 합니다.

배열을 선언하고 초기화하는 방법은 다음과 같습니다.

```java
// 선언
int[] arr;

// 초기화
arr = new int[10];

// 선언과 초기화를 동시에
int[] arr = new int[10];

// 값으로 초기화
int[] arr = {1, 2, 3, 4, 5};
```

배열의 각 요소는 인덱스를 사용하여 접근할 수 있으며, 인덱스는 0부터 시작합니다.

```java
arr[0] = 1; // 배열의 첫 번째 요소에 1을 할당
int x = arr[0]; // 배열의 첫 번째 요소를 x에 할당
```

### Java 컬렉션: ArrayList, HashMap, HashSet

**ArrayList**

`ArrayList`는 동적 배열을 구현한 클래스입니다. 배열과 달리 `ArrayList`는 크기가 동적으로 변화하며, 객체만을 요소로 가집니다.

```java
ArrayList<String> list = new ArrayList<String>();
list.add("Java"); // 요소 추가
String item = list.get(0); // 요소 접근
```

**HashMap**

`HashMap`은 키-값 쌍을 저장하는 데 사용되는 자료구조입니다. 각 키는 유일해야 하며, 하나의 키는 하나의 값을 가리킵니다.

```java
HashMap<String, Integer> map = new HashMap<String, Integer>();
map.put("Apple", 1); // 요소 추가
int value = map.get("Apple"); // 요소 접근
```

**HashSet**

`HashSet`은 유일한 요소를 저장하는 데 사용되는 자료구조입니다. 중복된 요소를 허용하지 않으며, 요소의 순서를 유지하지 않습니다.

```java
HashSet<String> set = new HashSet<String>();
set.add("Java"); // 요소 추가
boolean isExists = set.contains("Java"); // 요소 확인
```

### Java 클래스와 인스턴스

**클래스**는 객체 지향 프로그래밍의 중요한 요소로, 객체의 상태와 행동을 정의하는 데 사용되는 템플릿입니다. 클래스는 멤버 변수(상태)와 메소드(행동)를 가질 수 있습니다.

```java
public class Car {
    String color; // 멤버 변수

    void drive() { // 메소드
        // 코드
    }
}
```

**인스턴스**는 클래스의 구체적인 예입니다. 클래스는 설계도와 같으며, 이 설계도를 기반으로 생성된 각 객체를 인스턴스라고 합니다

.

```java
Car car = new Car(); // Car 클래스의 인스턴스 생성
```

인스턴스는 클래스에 정의된 멤버 변수와 메소드를 가집니다. 각 인스턴스는 독립적인 상태를 가지며, 하나의 인스턴스의 상태가 다른 인스턴스에 영향을 주지 않습니다.

### Java 상속과 추상 클래스

**상속**은 부모 클래스의 속성과 메소드를 자식 클래스가 받아 사용할 수 있는 객체 지향 프로그래밍의 특징입니다. 이를 통해 코드의 재사용성이 증가하며, 코드의 구조화가 가능해집니다. Java에서는 `extends` 키워드를 사용하여 상속을 구현합니다.

```java
public class Car {
    // 코드
}

public class SportsCar extends Car {
    // Car 클래스의 모든 멤버를 상속받음
}
```

**추상 클래스**는 하나 이상의 추상 메소드를 포함하는 클래스입니다. 추상 메소드는 선언만 있고 구현은 없는 메소드를 말하며, 이 메소드의 구현은 서브 클래스에서 담당합니다. 추상 클래스는 `abstract` 키워드를 사용하여 선언하며, 인스턴스를 직접 생성할 수 없습니다.

```java
public abstract class AbstractClass {
    abstract void abstractMethod(); // 추상 메소드
}
```

이를 상속하는 서브 클래스는 반드시 추상 메소드를 구현해야 합니다.

```java
public class SubClass extends AbstractClass {
    void abstractMethod() {
        // 구현 코드
    }
}
```